! External mechanical forcing.
! This file contains the expression used for the external
! mechanical forcing. You can use temporary real arrays
! R1-R3 of size (1:n,1:n,ksta:kend) and temporary complex
! arrays C1-C8 of size (n,n,ista:iend) to do intermediate
! computations. The variable f0 should control the global
! amplitude of the forcing, and variables fparam0-9 can be
! used to control the amplitudes of individual terms. At the
! end, the three components of the forcing in spectral
! space should be stored in the arrays fx, fy, and fz.

! Superposition of Taylor-Green vortices
!     kdn : minimum wave number
!     kup : maximum wave number
!     u0  : velocity magnitude

!$omp parallel do if (iend-ista.ge.nth) private (j,k)
      DO i = ista,iend
!$omp parallel do if (iend-ista.lt.nth) private (k)
         DO j = 1,n
            DO k = 1,n
               vz(k,j,i) = 0.0_GP
            END DO
         END DO
      END DO

      R1 = 0.0_GP
      R2 = 0.0_GP
!$omp parallel do if (kend-ksta.ge.nth) private (j,i)
      DO k = ksta,kend
!$omp parallel do if (kend-ksta.lt.nth) private (i)
         DO j = 1,n
            DO i = 1,n

               R1(i,j,k) =                 COS(4*pi*(real(i,kind=GP)-1)/ &
                          real(n,kind=GP))*SIN(4*pi*(real(j,kind=GP)-1)/  &
                          real(n,kind=GP))*COS(4*pi*(real(k,kind=GP)-1)/  &
                          real(n,kind=GP))
               R2(i,j,k) =                -SIN(4*pi*(real(i,kind=GP)-1)/ &
                          real(n,kind=GP))*COS(4*pi*(real(j,kind=GP)-1)/  &
                          real(n,kind=GP))*COS(4*pi*(real(k,kind=GP)-1)/  &
                          real(n,kind=GP))

            END DO
         END DO
      END DO

      CALL fftp3d_real_to_complex(planrc,R1,vx,MPI_COMM_WORLD)
      CALL fftp3d_real_to_complex(planrc,R2,vy,MPI_COMM_WORLD)

!     DO i = ista,iend
!       DO j = 1,n
!         DO k = 1,n
!           IF ((ka2(k,j,i).lt.kdn**2).or.(ka2(k,j,i).gt.kup**2)) THEN
!             vx(k,j,i) = 0.0
!             vy(k,j,i) = 0.0
!             vz(k,j,i) = 0.0
!           ENDIF
!         END DO
!       END DO
!    END DO

     CALL normalize(vx,vy,vz,u0,1,MPI_COMM_WORLD)

! Randomize phases:
     IF (myrank.eq.0) phase = 2*pi*randu(seed)
     CALL MPI_BCAST(phase,1,GC_REAL,0,MPI_COMM_WORLD,ierr)
     cdump = COS(phase)+im*SIN(phase)
     jdump = conjg(cdump)

     IF (ista.eq.1) THEN
!$omp parallel do
        DO j = 2,n/2+1
          C1    (1,j,1) = vx    (1,j,1)*cdump
          C1(1,n-j+2,1) = vx(1,n-j+2,1)*jdump
          C2    (1,j,1) = vy    (1,j,1)*cdump
          C2(1,n-j+2,1) = vy(1,n-j+2,1)*jdump
          C3    (1,j,1) = vz    (1,j,1)*cdump
          C3(1,n-j+2,1) = vz(1,n-j+2,1)*jdump
        END DO
!$omp parallel do
        DO k = 2,n/2+1
          C1    (k,1,1) = vx    (k,1,1)*cdump
          C1(n-k+2,1,1) = vx(n-k+2,1,1)*jdump
          C2    (k,1,1) = vy    (k,1,1)*cdump
          C2(n-k+2,1,1) = vy(n-k+2,1,1)*jdump
          C3    (k,1,1) = vz    (k,1,1)*cdump
          C3(n-k+2,1,1) = vz(n-k+2,1,1)*jdump
        END DO
!$omp parallel do private (k)
        DO j = 2,n
          DO k = 2,n/2+1
            C1        (k,j,1) = vx        (k,j,1)*cdump
            C1(n-k+2,n-j+2,1) = vx(n-k+2,n-j+2,1)*jdump
            C2        (k,j,1) = vy        (k,j,1)*cdump
            C2(n-k+2,n-j+2,1) = vy(n-k+2,n-j+2,1)*jdump
            C3        (k,j,1) = vz        (k,j,1)*cdump
            C3(n-k+2,n-j+2,1) = vz(n-k+2,n-j+2,1)*jdump
          END DO
        END DO
!$omp parallel do if (iend-2.ge.nth) private (j,k)
        DO i = 2,iend
!$omp parallel do if (iend-2.lt.nth) private (k)
          DO j = 1,n
            DO k = 1,n
              C1(k,j,i) = vx(k,j,i)*cdump
              C2(k,j,i) = vy(k,j,i)*cdump
              C3(k,j,i) = vz(k,j,i)*cdump
            END DO
          END DO
        END DO
      ELSE
!$omp parallel do if (iend-ista.ge.nth) private (j,k)
        DO i = ista,iend
!$omp parallel do if (iend-ista.lt.nth) private (k)
          DO j = 1,n
            DO k = 1,n
              C1(k,j,i) = vx(k,j,i)*cdump
              C2(k,j,i) = vy(k,j,i)*cdump
              C3(k,j,i) = vz(k,j,i)*cdump
            END DO
          END DO
        END DO
     ENDIF

     CALL rotor3(C2,C3,vx,1)
     CALL rotor3(C1,C3,vy,2)
     CALL rotor3(C1,C2,vz,3)
     CALL normalize(vx,vy,vz,u0,1,MPI_COMM_WORLD)

